<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>Implementing a Merkle Tree in Python | Lennart Breede</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="In this article, we will implement a Merkle Tree in Python, a data structure used extensively in Blockchain technology and other systems requiring data integrity verification. By the end of this article, you will understand how Merkle Trees work, their benefits, what the Merkle Root is, and how to implement all of this in Python.
The Merkle Tree A Merkle Tree is a binary hash tree that hashes a collection of data blocks so that any change in the original data results in entirely different values throughout the tree.">
    <meta name="generator" content="Hugo 0.128.0">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/2024-07-02-implementing-a-merkle-tree-in-python/">
    

    <meta property="og:url" content="http://localhost:1313/posts/2024-07-02-implementing-a-merkle-tree-in-python/">
  <meta property="og:site_name" content="Lennart Breede">
  <meta property="og:title" content="Implementing a Merkle Tree in Python">
  <meta property="og:description" content="In this article, we will implement a Merkle Tree in Python, a data structure used extensively in Blockchain technology and other systems requiring data integrity verification. By the end of this article, you will understand how Merkle Trees work, their benefits, what the Merkle Root is, and how to implement all of this in Python.
The Merkle Tree A Merkle Tree is a binary hash tree that hashes a collection of data blocks so that any change in the original data results in entirely different values throughout the tree.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2024-07-02T12:00:00+00:00">
    <meta property="article:modified_time" content="2024-07-02T12:00:00+00:00">

  <meta itemprop="name" content="Implementing a Merkle Tree in Python">
  <meta itemprop="description" content="In this article, we will implement a Merkle Tree in Python, a data structure used extensively in Blockchain technology and other systems requiring data integrity verification. By the end of this article, you will understand how Merkle Trees work, their benefits, what the Merkle Root is, and how to implement all of this in Python.
The Merkle Tree A Merkle Tree is a binary hash tree that hashes a collection of data blocks so that any change in the original data results in entirely different values throughout the tree.">
  <meta itemprop="datePublished" content="2024-07-02T12:00:00+00:00">
  <meta itemprop="dateModified" content="2024-07-02T12:00:00+00:00">
  <meta itemprop="wordCount" content="1356">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="Implementing a Merkle Tree in Python">
  <meta name="twitter:description" content="In this article, we will implement a Merkle Tree in Python, a data structure used extensively in Blockchain technology and other systems requiring data integrity verification. By the end of this article, you will understand how Merkle Trees work, their benefits, what the Merkle Root is, and how to implement all of this in Python.
The Merkle Tree A Merkle Tree is a binary hash tree that hashes a collection of data blocks so that any change in the original data results in entirely different values throughout the tree.">

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Lennart Breede
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">Implementing a Merkle Tree in Python</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2024-07-02T12:00:00Z">July 2, 2024</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>In this article, we will implement a Merkle Tree in Python, a data structure used extensively in Blockchain technology and other systems requiring data integrity verification. By the end of this article, you will understand how Merkle Trees work, their benefits, what the Merkle Root is, and how to implement all of this in Python.</p>
<h2 id="the-merkle-tree">The Merkle Tree</h2>
<p>A <em>Merkle Tree</em> is a binary hash tree that hashes a collection of data blocks so that any change in the original data results in entirely different values throughout the tree. This makes it helpful in verifying the integrity of the data and tracking down changes efficiently through binary traversal.</p>
<p><img src="hash_tree.png" alt="An example of a binary hash tree. Hashes 0-0 and 0-1 are the hash values of data blocks L1 and L2, respectively, and hash 0 is the hash of the concatenation of hashes 0-0 and 0-1."></p>
<p>The leaf nodes contain the hash value of each data block. The nodes are then grouped in pairs, their hashes are concatenated, and the resulting string is hashed again. This process continues until only one node, known as the Merkle Root, is left, marking the culmination of the Merkle Tree.</p>
<h2 id="the-merkle-root">The Merkle Root</h2>
<p>The Merkle Tree&rsquo;s root node contains a hash dependent on all preceding hashes and, therefore, the underlying data blocks. This makes the <em>Merkle Root</em> a critical value, the cornerstone of data verification. It&rsquo;s the key to checking and verifying the entire collection of data blocks. In the case of a failing verification, a binary tree traversal can then be utilized to locate the faulty data block. Now, let&rsquo;s delve into how we can implement the Merkle Root in Python.</p>
<h2 id="implementing-the-merkle-root-in-python">Implementing the Merkle Root in Python</h2>
<p>To generate the Merkle Root in Python, we can create a recursive function that takes a list of hashes as an argument.
You can choose any hash function, but in this example, we will extensively use SHA-256, which warrants creating a helper function that takes a string as an argument and returns its SHA-256 hash.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> hashlib
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">sha256</span>(s: str) <span style="color:#f92672">-&gt;</span> str:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> hashlib<span style="color:#f92672">.</span>sha256(s<span style="color:#f92672">.</span>encode())<span style="color:#f92672">.</span>hexdigest()
</span></span></code></pre></div><p>We concatenate every hash pair, create a new hash using our new helper function above, and store it in a new list. We can then pass this new list into the same function and recursively reduce the number of hashes until only one is left, the <em>Merkle Root</em>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_merkle_root</span>(hash_list: list[str]) <span style="color:#f92672">-&gt;</span> str:
</span></span><span style="display:flex;"><span>    new_hash_list <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(hash_list), <span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>        j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> len(hash_list) <span style="color:#66d9ef">else</span> i
</span></span><span style="display:flex;"><span>        string <span style="color:#f92672">=</span> hash_list[i] <span style="color:#f92672">+</span> hash_list[j]
</span></span><span style="display:flex;"><span>        new_hash_list<span style="color:#f92672">.</span>append(sha256(string))
</span></span></code></pre></div><p>Above, we loop over the given list&rsquo;s length with a step of two. The chosen step size lets us compare the current iteration with the next without overlap. For example, if the incoming <code>hash_list</code> is of length four, our variable <code>i</code> will have the value of <code>0</code> in the first iteration and <code>2</code> in the second. To get a pair on every iteration, we simply access <code>hash_list[i]</code> and <code>hash_list[i+1]</code>.
In the code above, we created the variable <code>j</code>. When we have an odd number of hashes, we skip the <code>i+1</code> step for the final iteration and use <code>i</code> again to avoid an index error.</p>
<p>Now, we want to recursively reduce the length of the hash list by passing the new hash list into <code>get_merkle_root()</code> again.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_merkle_root</span>(hash_list: list[str]) <span style="color:#f92672">-&gt;</span> str:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(hash_list) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> hash_list[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    new_hash_list <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(hash_list), <span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>        j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> len(hash_list) <span style="color:#66d9ef">else</span> i
</span></span><span style="display:flex;"><span>        string <span style="color:#f92672">=</span> hash_list[i] <span style="color:#f92672">+</span> hash_list[j]
</span></span><span style="display:flex;"><span>        new_hash_list<span style="color:#f92672">.</span>append(sha256(string))
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> get_merkle_root(new_hash_list)
</span></span></code></pre></div><p>To avoid getting stuck in endless recursion, we define our base case at the top, returning the list&rsquo;s first (and only) value if the length equals one. We&rsquo;ve almost handled every case now; lastly, let&rsquo;s write a final condition at the top for when we pass an empty list (for some reason).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_merkle_root</span>(hash_list: list[str]) <span style="color:#f92672">-&gt;</span> str:
</span></span><span style="display:flex;"><span>    <span style="color:#e6db74">&#34;&#34;&#34;Return the Merkle root of a list of hashes.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Args:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        hashes: A list of hashes.
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    Returns:
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">        The Merkle root of the hashes
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">    &#34;&#34;&#34;</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> hash_list:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> sha256(<span style="color:#e6db74">&#34;&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(hash_list) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> hash_list[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    new_hash_list <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(hash_list), <span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>        j <span style="color:#f92672">=</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#66d9ef">if</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> len(hash_list) <span style="color:#66d9ef">else</span> i
</span></span><span style="display:flex;"><span>        string <span style="color:#f92672">=</span> hash_list[i] <span style="color:#f92672">+</span> hash_list[j]
</span></span><span style="display:flex;"><span>        new_hash_list<span style="color:#f92672">.</span>append(sha256(string))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> get_merkle_root(new_hash_list)
</span></span></code></pre></div><p>Here we are, a function that returns the <em>Merkle Root</em> for a given list of hash values.</p>
<h2 id="transaction-data-structure">Transaction Data Structure</h2>
<p>Because <em>Merkle Trees</em> are heavily used to hash and verify large lists of transactions, we will use this as an example for our implementation.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">from</span> dataclasses <span style="color:#f92672">import</span> dataclass
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#a6e22e">@dataclass</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Transaction</span>:
</span></span><span style="display:flex;"><span>    sender: str
</span></span><span style="display:flex;"><span>    receiver: str
</span></span><span style="display:flex;"><span>    amount: int
</span></span><span style="display:flex;"><span>    timestamp: str
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">def</span> <span style="color:#a6e22e">to_hash</span>(self) <span style="color:#f92672">-&gt;</span> str:
</span></span><span style="display:flex;"><span>        string <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;&#34;</span><span style="color:#f92672">.</span>join(str(x) <span style="color:#66d9ef">for</span> x <span style="color:#f92672">in</span> vars(self)<span style="color:#f92672">.</span>values())
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> sha256(string)
</span></span><span style="display:flex;"><span>        
</span></span><span style="display:flex;"><span>type Tx <span style="color:#f92672">=</span> Transaction
</span></span></code></pre></div><p>We implement a <code>to_hash()</code> method to concatenate all transaction values and generate a SHA-256 hash of the resulting string.</p>
<p>With this in place, we can create a wrapper of <code>get_merkle_root()</code> to accept a list of transactions.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_tx_merkle_root</span>(txs: list[Tx]) <span style="color:#f92672">-&gt;</span> str:
</span></span><span style="display:flex;"><span>    hashes <span style="color:#f92672">=</span> [tx<span style="color:#f92672">.</span>to_hash <span style="color:#66d9ef">for</span> tx <span style="color:#f92672">in</span> txs]
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> get_merkle_root(hashes)
</span></span></code></pre></div><p>Below, we printed the list of transactions, their hashes and finally, their Merkle Root.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># Transactions</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>Transaction<span style="color:#f92672">(</span>sender<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Alice&#39;</span>,
</span></span><span style="display:flex;"><span>             receiver<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Bob&#39;</span>,
</span></span><span style="display:flex;"><span>             amount<span style="color:#f92672">=</span>20,
</span></span><span style="display:flex;"><span>             timestamp<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;2021-09-01T12:00:00&#39;</span><span style="color:#f92672">)</span>,
</span></span><span style="display:flex;"><span> Transaction<span style="color:#f92672">(</span>sender<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Bob&#39;</span>,
</span></span><span style="display:flex;"><span>             receiver<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Charlie&#39;</span>,
</span></span><span style="display:flex;"><span>             amount<span style="color:#f92672">=</span>50,
</span></span><span style="display:flex;"><span>             timestamp<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;2021-09-01T13:00:00&#39;</span><span style="color:#f92672">)</span>,
</span></span><span style="display:flex;"><span> Transaction<span style="color:#f92672">(</span>sender<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Charlie&#39;</span>,
</span></span><span style="display:flex;"><span>             receiver<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Alice&#39;</span>,
</span></span><span style="display:flex;"><span>             amount<span style="color:#f92672">=</span>10,
</span></span><span style="display:flex;"><span>             timestamp<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;2021-09-01T15:00:00&#39;</span><span style="color:#f92672">)]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Hashes</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#e6db74">&#39;97f23869f74000cd28239454f83cd5870a13170aa5b27011d46e45e3674e3c58&#39;</span>,
</span></span><span style="display:flex;"><span> <span style="color:#e6db74">&#39;7d01a35827cb305c52618157fe9250c355f38b2bb9d91ee487a190cb7baac788&#39;</span>,
</span></span><span style="display:flex;"><span> <span style="color:#e6db74">&#39;e3d4444714fe6d0660ed7907c42d671d4e766c342fb331689146165e58f49f7f&#39;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># The Merkle Root:</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;b447dbac50e48a16111032928282bf168cfe648b31d628fd0d6198fb2943cd9e&#39;</span>
</span></span></code></pre></div><p>If we modify one of the transactions, we will see how one of the transaction hashes changed completely, which in turn changed the Merkle Root.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># Transactions</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span>Transaction<span style="color:#f92672">(</span>sender<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Alice&#39;</span>,
</span></span><span style="display:flex;"><span>             receiver<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Bob&#39;</span>,
</span></span><span style="display:flex;"><span>             amount<span style="color:#f92672">=</span>20,
</span></span><span style="display:flex;"><span>             timestamp<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;2021-09-01T12:00:00&#39;</span><span style="color:#f92672">)</span>,
</span></span><span style="display:flex;"><span> Transaction<span style="color:#f92672">(</span>sender<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Bob&#39;</span>,
</span></span><span style="display:flex;"><span>             receiver<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Charlie&#39;</span>,
</span></span><span style="display:flex;"><span>             amount<span style="color:#f92672">=</span>51,
</span></span><span style="display:flex;"><span>             timestamp<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;2021-09-01T13:00:00&#39;</span><span style="color:#f92672">)</span>,
</span></span><span style="display:flex;"><span> Transaction<span style="color:#f92672">(</span>sender<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Charlie&#39;</span>,
</span></span><span style="display:flex;"><span>             receiver<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;Alice&#39;</span>,
</span></span><span style="display:flex;"><span>             amount<span style="color:#f92672">=</span>10,
</span></span><span style="display:flex;"><span>             timestamp<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;2021-09-01T15:00:00&#39;</span><span style="color:#f92672">)]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># Hashes</span>
</span></span><span style="display:flex;"><span><span style="color:#f92672">[</span><span style="color:#e6db74">&#39;97f23869f74000cd28239454f83cd5870a13170aa5b27011d46e45e3674e3c58&#39;</span>,
</span></span><span style="display:flex;"><span> <span style="color:#e6db74">&#39;a70fc1aaee70c3ebbf38eccd0005e6b0bf410b6f8a1f52e2480ded5753fe0e79&#39;</span>,
</span></span><span style="display:flex;"><span> <span style="color:#e6db74">&#39;e3d4444714fe6d0660ed7907c42d671d4e766c342fb331689146165e58f49f7f&#39;</span><span style="color:#f92672">]</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># The Merkle Root:</span>
</span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;9e3d45c68ec348363b23fe696c9f1d638224d6f195ffd03a3bff3ae6b1ed6bf9&#39;</span>
</span></span></code></pre></div><h2 id="implementing-a-merkle-tree-in-python">Implementing a Merkle Tree in Python</h2>
<p>If we want to track down which transactions need to be fixed, our approach needs to be revised since the <em>Merkle Root</em> can only tell us that something is wrong, but not exactly what. We can create a node data structure to hold a given hash value and, optionally, a left and right child node.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#a6e22e">@dataclass</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">MerkleNode</span>:
</span></span><span style="display:flex;"><span>    value: str
</span></span><span style="display:flex;"><span>    left: MerkleNode <span style="color:#f92672">|</span> <span style="color:#66d9ef">None</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>    right: MerkleNode <span style="color:#f92672">|</span> <span style="color:#66d9ef">None</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span></code></pre></div><p>This function will be very similar to the one creating the Merkle Root.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">get_merkle_tree</span>(nodes: list[MerkleNode]) <span style="color:#f92672">-&gt;</span> MerkleNode:
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">not</span> nodes:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> MerkleNode(sha256(<span style="color:#e6db74">&#34;&#34;</span>))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> len(nodes) <span style="color:#f92672">==</span> <span style="color:#ae81ff">1</span>:
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> nodes[<span style="color:#ae81ff">0</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e"># --snip--</span>
</span></span></code></pre></div><p>Instead of a list of strings, we now pass a list of nodes as the argument and return a single node.
Most of the change happens in the for-loop.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>    <span style="color:#75715e"># --snip--</span>
</span></span><span style="display:flex;"><span>    new_nodes <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(<span style="color:#ae81ff">0</span>, len(nodes), <span style="color:#ae81ff">2</span>):
</span></span><span style="display:flex;"><span>        left <span style="color:#f92672">=</span> nodes[i]
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> <span style="color:#f92672">&lt;</span> len(nodes):
</span></span><span style="display:flex;"><span>            right <span style="color:#f92672">=</span> nodes[i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>            string <span style="color:#f92672">=</span> left<span style="color:#f92672">.</span>value <span style="color:#f92672">+</span> right<span style="color:#f92672">.</span>value
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>            right <span style="color:#f92672">=</span> <span style="color:#66d9ef">None</span>
</span></span><span style="display:flex;"><span>            string <span style="color:#f92672">=</span> left<span style="color:#f92672">.</span>value <span style="color:#f92672">+</span> left<span style="color:#f92672">.</span>value
</span></span><span style="display:flex;"><span>        new_node <span style="color:#f92672">=</span> MerkleNode(sha256(string), left<span style="color:#f92672">=</span>left, right<span style="color:#f92672">=</span>right)
</span></span><span style="display:flex;"><span>        new_nodes<span style="color:#f92672">.</span>append(new_node)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> get_merkle_tree(new_nodes)
</span></span></code></pre></div><p>The range parameters and how we check if the value of <code>i+1</code> exceeds the list length stay the same. We concatenate the two hashes and create a new one like before. The main difference is that we wrap the hash in the Merkle node and, most importantly, store the two nodes we are currently processing as the left and right children of the new node. In the else block, we assign the right node to <code>None</code>, marking this child as missing.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>txs <span style="color:#f92672">=</span> [
</span></span><span style="display:flex;"><span>    Transaction(<span style="color:#e6db74">&#34;Alice&#34;</span>, <span style="color:#e6db74">&#34;Bob&#34;</span>, <span style="color:#ae81ff">20</span>, <span style="color:#e6db74">&#34;2021-09-01T12:00:00&#34;</span>),
</span></span><span style="display:flex;"><span>    Transaction(<span style="color:#e6db74">&#34;Bob&#34;</span>, <span style="color:#e6db74">&#34;Charlie&#34;</span>, <span style="color:#ae81ff">50</span>, <span style="color:#e6db74">&#34;2021-09-01T13:00:00&#34;</span>),
</span></span><span style="display:flex;"><span>    Transaction(<span style="color:#e6db74">&#34;Charlie&#34;</span>, <span style="color:#e6db74">&#34;Alice&#34;</span>, <span style="color:#ae81ff">10</span>, <span style="color:#e6db74">&#34;2021-09-01T15:00:00&#34;</span>),
</span></span><span style="display:flex;"><span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>tx_nodes <span style="color:#f92672">=</span> [MerkleNode(tx<span style="color:#f92672">.</span>to_hash()) <span style="color:#66d9ef">for</span> tx <span style="color:#f92672">in</span> txs]
</span></span><span style="display:flex;"><span>tx_tree <span style="color:#f92672">=</span> get_merkle_tree(tx_nodes)
</span></span></code></pre></div><p>We create our transactions again and wrap their hashes into nodes. We then pass them into our new function and store the result in the variable <code>tx_tree</code>.</p>
<p><img src="merkle_tree_before.png" alt="Merkle Tree before"></p>
<p>Revisiting our previous chapter, the verification process begins with the root node&rsquo;s hash value, which starts with <code>b447</code> and ends with <code>cd9e</code>. Equally important are the &rsquo;three leaf nodes&rsquo; at the bottom, which store the original hash representation of our three transactions. The tree&rsquo;s benefit lies in its ability to display all the branch nodes. Let&rsquo;s now proceed to create another tree with a slightly modified transaction.</p>
<p><img src="merkle_tree_after.png" alt="Merkle Tree after"></p>
<p>Comparing both trees, we can colourize the nodes of this tree green or red, whether or not they match the previous one, our ground truth. This visualization shows us that the second transaction from the left (Bob sending 50 units to Charlie) has been tampered with.</p>
<h2 id="conclusion">Conclusion</h2>
<p>Whether used for encoding transactions, verifying software updates, or ensuring the integrity of large data sets, the principles behind Merkle Trees highlight their versatility and importance in maintaining data security and reliability.</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  Lennart Breede 2024 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
