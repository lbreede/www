<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>VEX Ray Tracer #2: Plane Projection | Lennart Breede</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="Now let&rsquo;s get into it. I read in all three elements (plane, camera and scene) into the empty ray_tracer geometry.
Make sure to choose the camOrigin Add SOP inside the camera object to only merge in a single point instead of the camera visualizer. Also, transform into the object for both the camOrigin and the plane since they probably will have object transforms.
We are also adding point normals to the scene in case the come in on vertices or not at all.">
    <meta name="generator" content="Hugo 0.128.0">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/vrt02-plane-projection/">
    

    <meta property="og:url" content="http://localhost:1313/posts/vrt02-plane-projection/">
  <meta property="og:site_name" content="Lennart Breede">
  <meta property="og:title" content="VEX Ray Tracer #2: Plane Projection">
  <meta property="og:description" content="Now let’s get into it. I read in all three elements (plane, camera and scene) into the empty ray_tracer geometry.
Make sure to choose the camOrigin Add SOP inside the camera object to only merge in a single point instead of the camera visualizer. Also, transform into the object for both the camOrigin and the plane since they probably will have object transforms.
We are also adding point normals to the scene in case the come in on vertices or not at all.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-01-17T16:00:00+00:00">
    <meta property="article:modified_time" content="2021-01-17T16:00:00+00:00">

  <meta itemprop="name" content="VEX Ray Tracer #2: Plane Projection">
  <meta itemprop="description" content="Now let’s get into it. I read in all three elements (plane, camera and scene) into the empty ray_tracer geometry.
Make sure to choose the camOrigin Add SOP inside the camera object to only merge in a single point instead of the camera visualizer. Also, transform into the object for both the camOrigin and the plane since they probably will have object transforms.
We are also adding point normals to the scene in case the come in on vertices or not at all.">
  <meta itemprop="datePublished" content="2021-01-17T16:00:00+00:00">
  <meta itemprop="dateModified" content="2021-01-17T16:00:00+00:00">
  <meta itemprop="wordCount" content="1163">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="VEX Ray Tracer #2: Plane Projection">
  <meta name="twitter:description" content="Now let’s get into it. I read in all three elements (plane, camera and scene) into the empty ray_tracer geometry.
Make sure to choose the camOrigin Add SOP inside the camera object to only merge in a single point instead of the camera visualizer. Also, transform into the object for both the camOrigin and the plane since they probably will have object transforms.
We are also adding point normals to the scene in case the come in on vertices or not at all.">

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Lennart Breede
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">VEX Ray Tracer #2: Plane Projection</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2021-01-17T16:00:00Z">January 17, 2021</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>Now let&rsquo;s get into it. I read in all three elements (plane, camera and scene) into the empty ray_tracer geometry.</p>
<p>Make sure to choose the camOrigin Add SOP inside the camera object to only merge in a single point instead of the camera visualizer. Also, transform into the object for both the camOrigin and the plane since they probably will have object transforms.</p>
<p>We are also adding point normals to the scene in case the come in on vertices or not at all. Later, we might move that into the scene object, in case we want to mess with the cusp angle, until then, leave them all as default.</p>
<p><img src="02.001_object_merge.png" alt=""></p>
<p>Now we are going to turn the plane into a bunch of points. We will treat every primitive as the screens pixel, but since each primitive contains four points (as long as they&rsquo;re rectangles/squares) that are connected to other primitives, we need to create unique points for each primitive, before scaling them all down to a singular point.</p>
<p>For that, we simply append a Facet SOP to the plane check Unique Points, followed by a Primitive SOP with Do Transformation enabled and scale set to 0, 0, 0. This will now take each primitive and scale it down to a single point along it&rsquo;s centroid. We append a Fuse SOP since now we have four points on top of each other. Un-check Remove Unused Points from Degenerate Primitives to keep a single point and remove all primitive data. We now have one point instead of each primitive.</p>
<p><img src="02.002_prim_to_point.png" alt=""></p>
<p><em>Note the amount of points after the fuse and amount of primitives on the object merge.</em></p>
<p>Since we are left with a bunch of points now, we have to create an attribute that we can use to remember what primitive we came from. For that we can use the original primitive number as an ID on the points. And while we could create a primitive ID and promote it to points, why don&rsquo;t we use this opportunity to write our first line of VEX code. Create an Point Wrangle between the Facet and the Primitive SOP and write the following:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>i<span style="color:#960050;background-color:#1e0010">@</span>id <span style="color:#f92672">=</span> <span style="color:#a6e22e">pointprims</span>(<span style="color:#ae81ff">0</span>, <span style="color:#960050;background-color:#1e0010">@</span>ptnum)[<span style="color:#ae81ff">0</span>];
</span></span></code></pre></div><p>So what does this do? The pointprims() function returns an array with all primitive numbers each point is connected to. Since we appended the wrangle after the Facet, we know each point is only connected to a single primitive, therefore instead of writing an array with a single primitive number, we call the first (and only) index right away and save it in the integer attribute @id.</p>
<p><img src="02.003_create_prim_id.png" alt=""></p>
<p><em>You can see how we now have four points with the same ID. This means it worked.</em></p>
<p>Fusing the points later in the chain will keep the attribute, leaving one point per primitive with the id attribute to remember its original primitive by.</p>
<hr>
<p>Now we can finally start with our first piece of actual ray tracing. Create a Point Wrangle and connect all three elements to it. The &ldquo;pixel points&rdquo; go into the first input since it&rsquo;s what stores out results. I like to put the scene in the second input since we are going to use it the most. The camera goes into input three and we leave input four open for future lights.</p>
<p><img src="02.004_input_setup.png" alt=""></p>
<p>First, we need to define a ray direction going out from each point which we will use to shoot them into the scene, gathering information.</p>
<p>For that, we need to subtract the position of the camera, with the position of each point. We will normalize the resulting vector to make future near/far clipping values more predictable.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>vector pos <span style="color:#f92672">=</span> <span style="color:#960050;background-color:#1e0010">@</span>P;
</span></span><span style="display:flex;"><span>vector cam_pos <span style="color:#f92672">=</span> <span style="color:#a6e22e">point</span>(<span style="color:#ae81ff">2</span>, <span style="color:#e6db74">&#34;P&#34;</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>vector dir <span style="color:#f92672">=</span> <span style="color:#a6e22e">normalize</span>(pos <span style="color:#f92672">-</span> cam_pos);
</span></span></code></pre></div><p>You can temporarily store the vector dir in the normal attribute @N to check if the direction is correct.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@</span>N <span style="color:#f92672">=</span> dir; <span style="color:#75715e">//temporarily visualize dir vector.
</span></span></span></code></pre></div><p>Now, we can use our new direction vector to shoot a ray into our scene and see what we get.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>vector hit_p, hit_uv;
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> hit_prim <span style="color:#f92672">=</span> <span style="color:#a6e22e">intersect</span>(<span style="color:#ae81ff">1</span>, pos, dir<span style="color:#f92672">*</span><span style="color:#ae81ff">999</span>, hit_p, hit_uv);
</span></span></code></pre></div><p>We create two empty vectors called <code>hit_p</code> and <code>hit_uv</code> to store the hit position and the UVs of the hit primitive, which number is being stored in the hit_prim integer.</p>
<p>We use the intersect() function to check if a point will &ldquo;hit&rdquo; an object in the scene. For that we will temporarily multiply the dir vector by a big number to make sure we will reach the teapot in the scene.</p>
<p>The intersect function, as stated above, returns the primitive number of the prim that&rsquo;s intersected. If there is no primitive intersected by a given ray, It&rsquo;ll return -1.</p>
<p>Therefore we can check in with a simple condition if the hit_prim is -1 or not.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (hit_prim <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">@</span>Cd <span style="color:#f92672">=</span> {<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>,<span style="color:#ae81ff">1</span>};
</span></span><span style="display:flex;"><span>} <span style="color:#66d9ef">else</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#960050;background-color:#1e0010">@</span>Cd <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>From now on, we will stay in the first block of the if condition to save computing time since we can throw out any ray that doesn&rsquo;t hit anything and leave that black, aka {0,0,0};</p>
<p><img src="02.005_init_plane_proj.png" alt=""></p>
<p><em>Points that &ldquo;hit&rdquo; the teapot are coloured white, the rest stays black.</em></p>
<p>Congrats, you wrote your first ray tracer! Two more things before I let you go.</p>
<p>Firstly, let&rsquo;s store the colour of the object on the point colour instead of just turning it white. For that, I will add a couple more objects and give them different colours.</p>
<p>Instead of turning the points white, we need to gather an objects colour upon detection. For that, we make use of the primitive number and UVs that we get with the <code>intersect()</code> function. If you haven&rsquo;t heard of <code>primuv()</code> yet, you&rsquo;re missing out, it goes tremendously with intersect (also with <code>xyzdist()</code>, but that&rsquo;s for another day).</p>
<p>Select the previous code block we wrote and replace it with:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>vector color <span style="color:#f92672">=</span> {<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>,<span style="color:#ae81ff">0</span>};
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (hit_prim <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>) {
</span></span><span style="display:flex;"><span>    color <span style="color:#f92672">=</span> <span style="color:#a6e22e">primuv</span>(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Cd&#34;</span>, hit_prim, hit_uv);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@</span>Cd <span style="color:#f92672">=</span> color;
</span></span></code></pre></div><p>Since we initialize the colour vector with black, there is no need for the else statement anymore (unless you want to give empty space a different colour). When we do hit a primitive though, we collect it&rsquo;s colour at a particular uv coordinate. This will be particularly helpful with multicoloured objects or other attribute that need to be interpolated.</p>
<p><img src="02.006_gather_color.png" alt=""></p>
<p>The second thing we need to do, is to copy all the gathered information back onto our original plane. For that, all we need to do is use an <em>Attribute Copy</em> to copy over <em>Cd</em> with id set as the <em>Attribute to Match</em>.</p>
<p><img src="02.007_copy_over_color.png" alt=""></p>
<p>Hurray, we did it!</p>
<p>One thing I will add quickly is a max ray dist slider to the intersect function since I know I will forget otherwise. I will set it to 1,000 for now.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> maxraydist <span style="color:#f92672">=</span> <span style="color:#a6e22e">ch</span>(<span style="color:#e6db74">&#34;maxraydist&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> hit_prim <span style="color:#f92672">=</span> <span style="color:#a6e22e">intersect</span>(<span style="color:#ae81ff">1</span>, pos, dir<span style="color:#f92672">*</span>maxraydist, hit_p, hit_uv);
</span></span></code></pre></div><p>Now we can up-res the plane and see our teapots in glorious 320x240 px.</p>
<p><img src="02.008_final_upres.png" alt=""></p>
<hr>
<p>&lt; [[VEX Ray Tracer 01 - Initial Setup|Initial Setup]] | [[VEX Ray Tracer 03 - Supersampling Anti-Aliasing|Supersampling Anti-Aliasing]] &gt;</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  Lennart Breede 2024 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
