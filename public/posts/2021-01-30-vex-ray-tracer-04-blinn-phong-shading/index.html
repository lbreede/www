<!DOCTYPE html>
<html lang="en-us">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    
    <title>VEX Ray Tracer #4: Blinn-Phong Shading | Lennart Breede</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1">
    <meta name="description" content="How I&rsquo;ve been looking forward to this part. When I wrote this ray tracer for the first time, implementing the Blinn–Phong Reflection Model was one of my proudest achievements. Not because it&rsquo;s complicated or anything (it&rsquo;s actually pretty straightforward), but because it was the first time I translated a technical write-up and pseudo-code into something useful for my purpose. It was also the first time where I could&rsquo;ve stopped and have a working product.">
    <meta name="generator" content="Hugo 0.128.0">
    
    
    
    
      <meta name="robots" content="noindex, nofollow">
    
    

    
<link rel="stylesheet" href="/ananke/css/main.min.css" >



    

    
      

    

    

    
      <link rel="canonical" href="http://localhost:1313/posts/2021-01-30-vex-ray-tracer-04-blinn-phong-shading/">
    

    <meta property="og:url" content="http://localhost:1313/posts/2021-01-30-vex-ray-tracer-04-blinn-phong-shading/">
  <meta property="og:site_name" content="Lennart Breede">
  <meta property="og:title" content="VEX Ray Tracer #4: Blinn-Phong Shading">
  <meta property="og:description" content="How I’ve been looking forward to this part. When I wrote this ray tracer for the first time, implementing the Blinn–Phong Reflection Model was one of my proudest achievements. Not because it’s complicated or anything (it’s actually pretty straightforward), but because it was the first time I translated a technical write-up and pseudo-code into something useful for my purpose. It was also the first time where I could’ve stopped and have a working product.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2021-01-30T00:00:00+00:00">
    <meta property="article:modified_time" content="2021-01-30T00:00:00+00:00">

  <meta itemprop="name" content="VEX Ray Tracer #4: Blinn-Phong Shading">
  <meta itemprop="description" content="How I’ve been looking forward to this part. When I wrote this ray tracer for the first time, implementing the Blinn–Phong Reflection Model was one of my proudest achievements. Not because it’s complicated or anything (it’s actually pretty straightforward), but because it was the first time I translated a technical write-up and pseudo-code into something useful for my purpose. It was also the first time where I could’ve stopped and have a working product.">
  <meta itemprop="datePublished" content="2021-01-30T00:00:00+00:00">
  <meta itemprop="dateModified" content="2021-01-30T00:00:00+00:00">
  <meta itemprop="wordCount" content="1718">
  <meta name="twitter:card" content="summary">
  <meta name="twitter:title" content="VEX Ray Tracer #4: Blinn-Phong Shading">
  <meta name="twitter:description" content="How I’ve been looking forward to this part. When I wrote this ray tracer for the first time, implementing the Blinn–Phong Reflection Model was one of my proudest achievements. Not because it’s complicated or anything (it’s actually pretty straightforward), but because it was the first time I translated a technical write-up and pseudo-code into something useful for my purpose. It was also the first time where I could’ve stopped and have a working product.">

	
  </head>

  <body class="ma0 avenir bg-near-white">

    
   
  

  <header>
    <div class="bg-black">
      <nav class="pv3 ph3 ph4-ns" role="navigation">
  <div class="flex-l justify-between items-center center">
    <a href="/" class="f3 fw2 hover-white no-underline white-90 dib">
      
        Lennart Breede
      
    </a>
    <div class="flex-l items-center">
      

      
      
<div class="ananke-socials">
  
</div>

    </div>
  </div>
</nav>

    </div>
  </header>



    <main class="pb7" role="main">
      
  
  <article class="flex-l flex-wrap justify-between mw8 center ph3">
    <header class="mt4 w-100">
      <aside class="instapaper_ignoref b helvetica tracked ttu">
          
        Posts
      </aside>
      










  <div id="sharing" class="mt3 ananke-socials">
    
  </div>


      <h1 class="f1 athelas mt3 mb1">VEX Ray Tracer #4: Blinn-Phong Shading</h1>
      
      
      
      <time class="f6 mv4 dib tracked" datetime="2021-01-30T00:00:00Z">January 30, 2021</time>
      

      
      
    </header>
    <div class="nested-copy-line-height lh-copy serif f4 nested-links mid-gray pr4-l w-two-thirds-l"><p>How I&rsquo;ve been looking forward to this part. When I wrote this ray tracer for the first time, implementing the Blinn–Phong Reflection Model was one of my proudest achievements. Not because it&rsquo;s complicated or anything (it&rsquo;s actually pretty straightforward), but because it was the first time I translated a technical write-up and pseudo-code into something useful for my purpose. It was also the first time where I could&rsquo;ve stopped and have a working product.</p>
<p>Nothing too impressive in a time where real-time ray tracing is the cool kid on the block. But this was my kid, ugly and slow, but mine.</p>
<p>At this point, I would like to share two links that really helped me understand how this whole thing works and how to implement it.</p>
<p>The first links to a [YouTube video by Jeffrey Chastine about Lighting in OpenGL][https://www.youtube.com/watch?v=gFZqzVQrw84] where he goes over general lighting theory, Lambertian and Blinn-Phong reflectance.</p>
<p>The second one links to the [Blinn-Phong reflection model Wikipedia page][https://en.wikipedia.org/wiki/Blinn%E2%80%93Phong_reflection_model]. There are a couple of code snippets for various applications and as usual great images to show whats going on.</p>
<hr>
<p>We are going to start with some housekeeping by adding some controls to our scene objects to change &ldquo;materials&rdquo; on the fly and adding a light source, also with some properties. Not the most exciting thing in the world but it makes the grand reveal more rewarding when we move the light around or change the object&rsquo;s shininess.</p>
<p><img src="04.001.png" alt=""></p>
<p>As you can see, I moved the scene setup into my ray tracing setup. I don&rsquo;t want to jump back and forth so much to add and remove objects, adjust the shader etc. Especially once we have many objects with many different materials.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>vector diffuse_color <span style="color:#f92672">=</span> <span style="color:#a6e22e">chv</span>(<span style="color:#e6db74">&#34;diffuse_color&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">int</span> use_point_color <span style="color:#f92672">=</span> <span style="color:#a6e22e">chi</span>(<span style="color:#e6db74">&#34;use_point_color&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> ( use_point_color ) {
</span></span><span style="display:flex;"><span>    diffuse_color <span style="color:#f92672">*=</span> v<span style="color:#960050;background-color:#1e0010">@</span>Cd;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>v<span style="color:#960050;background-color:#1e0010">@</span>Cd <span style="color:#f92672">=</span> diffuse_color;
</span></span><span style="display:flex;"><span>v<span style="color:#960050;background-color:#1e0010">@</span>spec_color <span style="color:#f92672">=</span> <span style="color:#a6e22e">chv</span>(<span style="color:#e6db74">&#34;spec_color&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@</span>shininess <span style="color:#f92672">=</span> <span style="color:#a6e22e">ch</span>(<span style="color:#e6db74">&#34;shininess&#34;</span>);
</span></span></code></pre></div><p>The code is pretty simple. We handpick the colour for the diffuse and specular components, adjust the shininess to taste and even have a little tick box multiplying our Cd with the selected diffuse colour (the ever-present {0.2, 0.2, 0.2} is obviously the default, hence the dark teapots).</p>
<p>I&rsquo;m storing all these values in point attributes. The diffuse color will be stored in <code>Cd</code>, so we can keep the viewport preview.</p>
<hr>
<p>Next: a light source. For that, we just create a single point in space with two attributes. A colour and a strength value. Those two with the distance to the object will be enough to calculate the light.</p>
<p><img src="04.002.png" alt=""></p>
<p>Pretty simple stuff. I used a sphere primitive instead of a point since they are basically the same thing for what we&rsquo;re using it for and it&rsquo;s easier to see in my screenshot. The sphere is followed by two lines of code setting the light colour and intensity (or power).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@</span>Cd <span style="color:#f92672">=</span> <span style="color:#a6e22e">chv</span>(<span style="color:#e6db74">&#34;light_color&#34;</span>);
</span></span><span style="display:flex;"><span><span style="color:#960050;background-color:#1e0010">@</span>light_power <span style="color:#f92672">=</span> <span style="color:#a6e22e">ch</span>(<span style="color:#e6db74">&#34;light_power&#34;</span>);
</span></span></code></pre></div><p>I&rsquo;m once again storing the light color in the Cd for viewport preview.</p>
<p>Nice.</p>
<hr>
<p>And that&rsquo;s all we need to get started. Now let&rsquo;s get into the theory of it all (yay!).</p>
<p>We basically calculate two components. The object&rsquo;s Lambertian reflectance and its specular reflectance.</p>
<p>You might have seen a Lambert shader inside some 3D packages. It basically describes a rough shader with no highlights. It blends between the objects diffuse color at the brightest point and shadow-y darkness (usually black) at the darkest point .</p>
<p>The specular component adds on top of the lambertian. It&rsquo;s basically a sharp highlight on the object which makes the object look more shiny. The color of said highlight and how &ldquo;sharp&rdquo; the highlight is, can be defined on the shader.</p>
<p>This will make a lot more sense once we build it, so let&rsquo;s do just that.</p>
<hr>
<p>Let&rsquo;s first gather all the shading and light info we just created.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>vector light_pos <span style="color:#f92672">=</span> <span style="color:#a6e22e">point</span>(<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;P&#34;</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>vector light_color <span style="color:#f92672">=</span> <span style="color:#a6e22e">point</span>(<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;Cd&#34;</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> light_power <span style="color:#f92672">=</span> <span style="color:#a6e22e">point</span>(<span style="color:#ae81ff">3</span>, <span style="color:#e6db74">&#34;light_power&#34;</span>, <span style="color:#ae81ff">0</span>);
</span></span><span style="display:flex;"><span>    
</span></span><span style="display:flex;"><span>vector diffuse_color <span style="color:#f92672">=</span> <span style="color:#a6e22e">primuv</span>(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;Cd&#34;</span>, hit_prim, hit_uv);
</span></span><span style="display:flex;"><span>vector spec_color <span style="color:#f92672">=</span> <span style="color:#a6e22e">primuv</span>(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;spec_color&#34;</span>, hit_prim, hit_uv);
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">float</span> shininess <span style="color:#f92672">=</span> <span style="color:#a6e22e">primuv</span>(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;shininess&#34;</span>, hit_prim, hit_uv);
</span></span></code></pre></div><p>We&rsquo;re reading in the light properties with the point function since we don&rsquo;t have to interpolate any values in between points like we might have to in the future for objects.</p>
<p>The shading properties are read with the primuv like in <a href="https://lbreede.github.io/vex-ray-tracer/2021/01/17/plane-projection.html">Part 2</a>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>vector hit_nml <span style="color:#f92672">=</span> <span style="color:#a6e22e">primuv</span>(<span style="color:#ae81ff">1</span>, <span style="color:#e6db74">&#34;N&#34;</span>, hit_prim, hit_uv);
</span></span></code></pre></div><p>We can also get the normal of the this way, which we will need in the next section.</p>
<p><img src="04.004.png" alt=""></p>
<hr>
<p>To calculate both the lambertian and the specular component, we need to calculate four normalized vectors with the data we got. We need:</p>
<ol>
<li>
<p>The view direction (V) which is the direction of the hit position to the eye (or pixel), which is basically the negated dir vector we use to shoot the rays into the scene.</p>
</li>
<li>
<p>The object&rsquo;s normal (N) that we can gather the same way as the color using the primuv function.</p>
</li>
<li>
<p>The light direction (L), which is the direction from the hit position to the lights source.</p>
</li>
<li>
<p>The half direction (H), which is the half vector (in between) the view direction and the light direction.</p>
</li>
</ol>
<p><img src="04.003.png" alt=""></p>
<p>Ignore the reflection vector (R). It&rsquo;s being used for the classic Phong shading method.</p>
<p>Extra credit for whomever builds a toggle to switch between both models.</p>
<hr>
<p>Let&rsquo;s start with the lambertian. It&rsquo;s basically the dot product of the light direction and the surface normal. So let&rsquo;s build these first.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>vector normal <span style="color:#f92672">=</span> <span style="color:#a6e22e">normalize</span>(hit_nml);
</span></span><span style="display:flex;"><span>vector light_dir <span style="color:#f92672">=</span> light_pos <span style="color:#f92672">-</span> hit_pos;
</span></span></code></pre></div><p>I normalize the normal here in case the hit normal comes in the wrong scale. I also renamed the hit_p variable to hit_pos to enforce a naming convention (light_pos, hit_pos, etc.).</p>
<p>The reason why I don&rsquo;t normalize the light direction just yet, is because we need the distance of the light for later to calculate it&rsquo;s intensity. So before normalizing, I store the length of the light direction vector in a float attribute.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> distance <span style="color:#f92672">=</span> <span style="color:#a6e22e">length</span>(light_dir);
</span></span><span style="display:flex;"><span>distance <span style="color:#f92672">=</span> distance <span style="color:#f92672">*</span> distance;
</span></span><span style="display:flex;"><span>light_dir <span style="color:#f92672">=</span> <span style="color:#a6e22e">normalize</span>(light_dir);
</span></span></code></pre></div><p>We also need to square the distance since light has a quadratic falloff. The reason why we don&rsquo;t use the power function pow() is because it is significantly slower than just multiplying two values together. So whenever you have an integer as an exponent, multiply the values.</p>
<p>That&rsquo;s all we need for the Lambertian.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> lambertian <span style="color:#f92672">=</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">dot</span>(light_dir, normal), <span style="color:#ae81ff">0.0</span>);
</span></span></code></pre></div><p>Since a dot product returns values between -1 and 1, we use the max function as a lower-end clamp. Now the value is somewhere between 0 and 1.</p>
<p>And at last, the final colour.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>color <span style="color:#f92672">=</span> diffuse_color <span style="color:#f92672">*</span> lambertian <span style="color:#f92672">*</span> light_color <span style="color:#f92672">*</span> light_power <span style="color:#f92672">/</span> distance;
</span></span></code></pre></div><p><img src="04.005.png" alt=""></p>
<p>And that&rsquo;s it. Now we have three perfectly rough teapots, floating through space.</p>
<p>We can now start playing with the colours of the objects and the light or the position of the light. The scene should still be small enough to give you real-time feedback.</p>
<hr>
<p>Now the specular.</p>
<p>For optimization, we can already decide, that if the Lambertian value is 0, meaning facing away from the light, we don&rsquo;t have to bother calculating the specular. So we can default the specular to 0.0 and open an if statement after that.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> specular <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> (lambertian <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">0.0</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// do something!
</span></span></span><span style="display:flex;"><span><span style="color:#75715e"></span>}
</span></span></code></pre></div><p>Let&rsquo;s start by making these other two vectors we needed, the view direction and the half direction.</p>
<p>As stated above, the view direction should be nothing but the inverse of the dir vector we use to shoot the rays into the scene.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>vector view_dir <span style="color:#f92672">=</span> <span style="color:#a6e22e">normalize</span>(<span style="color:#f92672">-</span>dir);
</span></span></code></pre></div><p>To create the half direction, we need to calculate the half vector between the light direction and the view direction. That as easy as adding the two vectors together and the normalizing them.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>vector half_dir <span style="color:#f92672">=</span> <span style="color:#a6e22e">normalize</span>(light_dir <span style="color:#f92672">+</span> view_dir);
</span></span></code></pre></div><p>Done.</p>
<p>Similar to the Lambertian formula, we have to calculate another dot product. This time between the light dir and the view dir. That is because the specular angle is supposed to move whenever the camera moves since it&rsquo;s a pseudo-reflection of the light source. The Lambertian stays the same, regardless of camera position.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#66d9ef">float</span> spec_angle <span style="color:#f92672">=</span> <span style="color:#a6e22e">max</span>(<span style="color:#a6e22e">dot</span>(half_dir, normal), <span style="color:#ae81ff">0.0</span>);
</span></span></code></pre></div><p>And again, we clamp the lower end of the dot product.</p>
<p>For now, let&rsquo;s write that spec angle into our specular float and add the whole thing to the color output.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>specular <span style="color:#f92672">=</span> spec_angle;
</span></span></code></pre></div><p>We use a similar formula as for the Lambertian.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>color <span style="color:#f92672">=</span> diffuse_color <span style="color:#f92672">*</span> lambertian <span style="color:#f92672">*</span> light_color <span style="color:#f92672">*</span> light_power <span style="color:#f92672">/</span> distance
</span></span><span style="display:flex;"><span>	<span style="color:#f92672">+</span> spec_color <span style="color:#f92672">*</span> specular <span style="color:#f92672">*</span> light_color <span style="color:#f92672">*</span> light_power <span style="color:#f92672">/</span> distance;
</span></span></code></pre></div><p><img src="04.006.png" alt=""></p>
<p>We are very close. But as you can see, the highlights are really blown out and the reflection is very broad/rough-looking.</p>
<p>That&rsquo;s because we have not yet introduced our shininess value. It serves as the exponent of our specular angle. So instead of writing the spec angle to my specular, let&rsquo;s use the power function on it instead.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>specular <span style="color:#f92672">=</span> <span style="color:#a6e22e">pow</span>(spec_angle, shininess);
</span></span></code></pre></div><p>The reason why we have to use the pow function here, is because the shininess value can be a float instead of and integer, plus it&rsquo;s encouraged to change the value to taste.</p>
<p><img src="04.007.png" alt=""></p>
<p>This looks more like it.</p>
<p>And that&rsquo;s it. That&rsquo;s the whole thing. Not too hard right?</p>
<hr>
<p>Important addition, when researching this topic, you might stumble across two additional components besides the lambert and the specular. Ambient and emission. Those are basically two additional colours added on top of the final colour formula. One is for filling in these deep black shadows and the other to create a &ldquo;glow&rdquo;. I don&rsquo;t like the results I get with the ambient since it uniformly lifts the material colour linearly toward the set value. I prefer adding additional weaker lights to fill in those areas. The emit works sometimes if used in the right context. Both components do not take lights into account. If you do choose to add them, here is the final formula:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span>color <span style="color:#f92672">=</span> diffuse_color <span style="color:#f92672">*</span> lambertian <span style="color:#f92672">*</span> light_color <span style="color:#f92672">*</span> light_power <span style="color:#f92672">/</span> distance
</span></span><span style="display:flex;"><span>	  <span style="color:#f92672">+</span> spec_color    <span style="color:#f92672">*</span> specular   <span style="color:#f92672">*</span> light_color <span style="color:#f92672">*</span> light_power <span style="color:#f92672">/</span> distance
</span></span><span style="display:flex;"><span>	  <span style="color:#f92672">+</span> emit_color
</span></span><span style="display:flex;"><span>	  <span style="color:#f92672">+</span> ambient_color;
</span></span></code></pre></div><hr>
<p>I encourage everyone now to play with the shading and light properties.</p>
<p>For example, changing the shininess value to 1 is equivalent to setting the specular to the raw spec angle without the power function and see how the specular highlight behaves when increasing it again.</p>
<p><img src="04.008.png" alt=""></p>
<p>Final result with extra test geo.</p>
<hr>
<p>&lt; [[VEX Ray Tracer 03 - Supersampling Anti-Aliasing|Supersampling Anti-Aliasing]] |</p>
<ul class="pa0">
  
</ul>
<div class="mt6 instapaper_ignoref">
      
      
      </div>
    </div>

    <aside class="w-30-l mt6-l">




</aside>

  </article>

    </main>
    <footer class="bg-black bottom-0 w-100 pa3" role="contentinfo">
  <div class="flex justify-between">
  <a class="f4 fw4 hover-white no-underline white-70 dn dib-ns pv2 ph3" href="http://localhost:1313/" >
    &copy;  Lennart Breede 2024 
  </a>
    <div>
<div class="ananke-socials">
  
</div>
</div>
  </div>
</footer>

  </body>
</html>
